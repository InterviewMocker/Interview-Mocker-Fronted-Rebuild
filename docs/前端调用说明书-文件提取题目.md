# 前端调用说明书 - 文件提取题目

> 通过上传包含面试题的文件（.txt / .md / .docx / .pdf），后端使用 LLM 自动提取题目并以 SSE 流式返回。
> 提取结果在服务端持久化缓存，前端刷新页面不丢失。

---

## 1. 接口总览

| 方法 | 路径 | 说明 |
|------|------|------|
| `POST` | `/api/v1/questions/extract` | 上传文件并提取题目（SSE 流式返回） |
| `GET` | `/api/v1/questions/extract/tasks` | 获取提取任务列表 |
| `GET` | `/api/v1/questions/extract/tasks/{task_id}` | 获取任务详情（含完整题目，用于刷新恢复） |
| `POST` | `/api/v1/questions/extract/import` | 将提取结果批量导入题库 |

**所有接口需要 Bearer Token 认证。**

---

## 2. 上传文件并提取题目

### 请求

```
POST /api/v1/questions/extract
Content-Type: multipart/form-data
Authorization: Bearer <token>
```

| 字段 | 类型 | 必填 | 说明 |
|------|------|------|------|
| `file` | File | 是 | 上传的文件，支持 `.txt` `.md` `.docx` `.pdf`，最大 50MB |
| `bank_id` | string | 是 | 目标题库 ID |

### 前端代码示例

```javascript
async function extractQuestionsFromFile(file, bankId, token) {
  const formData = new FormData();
  formData.append('file', file);
  formData.append('bank_id', bankId);

  const response = await fetch('/api/v1/questions/extract', {
    method: 'POST',
    headers: {
      'Authorization': `Bearer ${token}`,
      // 注意：不要手动设置 Content-Type，浏览器会自动处理 multipart boundary
    },
    body: formData,
  });

  // 读取 SSE 事件流
  const reader = response.body.getReader();
  const decoder = new TextDecoder();
  let buffer = '';
  let taskId = null;
  const allQuestions = [];

  while (true) {
    const { done, value } = await reader.read();
    if (done) break;

    buffer += decoder.decode(value, { stream: true });
    const lines = buffer.split('\n');
    buffer = lines.pop(); // 保留未完成的行

    let currentEvent = '';
    for (const line of lines) {
      if (line.startsWith('event: ')) {
        currentEvent = line.slice(7).trim();
      } else if (line.startsWith('data: ')) {
        const data = JSON.parse(line.slice(6));
        handleSSEEvent(currentEvent, data, taskId, allQuestions);

        if (currentEvent === 'task_created') {
          taskId = data.task_id;
        }
      }
    }
  }

  return { taskId, questions: allQuestions };
}

function handleSSEEvent(event, data, taskId, allQuestions) {
  switch (event) {
    case 'task_created':
      console.log('任务创建:', data.task_id);
      console.log(`文件: ${data.filename}, 分为 ${data.total_chunks} 块处理`);
      // 保存 task_id 到 localStorage，用于刷新恢复
      localStorage.setItem('current_extraction_task', data.task_id);
      break;

    case 'chunk_progress':
      console.log(`进度: ${data.progress}% (${data.chunk}/${data.total_chunks})`);
      console.log(`本批新增 ${data.new_questions.length} 道题，累计 ${data.total_questions_so_far} 道`);
      allQuestions.push(...data.new_questions);
      // 更新 UI 进度条和题目列表
      break;

    case 'completed':
      console.log(`提取完成！共 ${data.total_questions} 道题目`);
      localStorage.removeItem('current_extraction_task');
      break;

    case 'error':
      console.error('提取出错:', data.message);
      if (data.partial_questions) {
        console.log(`已部分提取 ${data.partial_questions.length} 道题`);
      }
      break;
  }
}
```

### SSE 事件类型

#### `task_created` — 任务已创建

```json
{
  "task_id": "550e8400-e29b-41d4-a716-446655440000",
  "filename": "Python面试题.pdf",
  "total_chunks": 3,
  "text_length": 15000
}
```

#### `chunk_progress` — 分块处理进度

每处理完一个文本块就推送一次：

```json
{
  "task_id": "550e8400-...",
  "chunk": 2,
  "total_chunks": 3,
  "progress": 66.7,
  "new_questions": [
    {
      "title": "Python中GIL是什么？",
      "content": "请解释Python中的GIL（全局解释器锁）...",
      "type": "technical",
      "category": "Python",
      "difficulty": "medium",
      "difficulty_score": 6,
      "tags": ["Python", "并发", "GIL"],
      "reference_answer": "GIL是CPython中的...",
      "answer_key_points": ["保证线程安全", "限制多线程并行"]
    }
  ],
  "total_questions_so_far": 8
}
```

#### `completed` — 提取完成

```json
{
  "task_id": "550e8400-...",
  "total_questions": 12,
  "questions": [/* 所有题目的完整数组 */]
}
```

#### `error` — 出错

```json
{
  "task_id": "550e8400-...",
  "message": "提取过程出错: LLM 服务超时",
  "partial_questions": [/* 已提取的部分题目 */]
}
```

---

## 3. 刷新恢复 — 获取任务详情

前端刷新页面后，可通过之前保存的 `task_id` 恢复提取结果：

### 请求

```
GET /api/v1/questions/extract/tasks/{task_id}
Authorization: Bearer <token>
```

### 响应

```json
{
  "code": 200,
  "message": "获取成功",
  "data": {
    "task_id": "550e8400-...",
    "filename": "Python面试题.pdf",
    "bank_id": "bank-001",
    "status": "completed",
    "total_chunks": 3,
    "processed_chunks": 3,
    "progress": 100.0,
    "questions": [
      {
        "title": "Python中GIL是什么？",
        "content": "...",
        "type": "technical",
        "category": "Python",
        "difficulty": "medium",
        "difficulty_score": 6,
        "tags": ["Python", "并发"],
        "reference_answer": "...",
        "answer_key_points": ["...", "..."]
      }
    ],
    "error": null,
    "created_at": 1739577600.0,
    "updated_at": 1739577620.0
  }
}
```

### 前端刷新恢复示例

```javascript
async function restoreExtractionTask(token) {
  const taskId = localStorage.getItem('current_extraction_task');
  if (!taskId) return null;

  const response = await fetch(`/api/v1/questions/extract/tasks/${taskId}`, {
    headers: { 'Authorization': `Bearer ${token}` },
  });

  const result = await response.json();
  const task = result.data;

  if (task.status === 'completed') {
    // 提取已完成，直接展示结果
    localStorage.removeItem('current_extraction_task');
    return task.questions;
  } else if (task.status === 'processing') {
    // 仍在处理中（服务端仍在跑），轮询获取最新状态
    return pollTaskStatus(taskId, token);
  } else if (task.status === 'failed') {
    // 提取失败，展示部分结果
    console.error('提取失败:', task.error);
    return task.questions; // 可能有部分结果
  }
}

async function pollTaskStatus(taskId, token, interval = 3000) {
  return new Promise((resolve) => {
    const timer = setInterval(async () => {
      const res = await fetch(`/api/v1/questions/extract/tasks/${taskId}`, {
        headers: { 'Authorization': `Bearer ${token}` },
      });
      const result = await res.json();
      const task = result.data;

      if (task.status === 'completed' || task.status === 'failed') {
        clearInterval(timer);
        localStorage.removeItem('current_extraction_task');
        resolve(task.questions);
      }
      // 可在此更新 UI 进度
    }, interval);
  });
}
```

---

## 4. 获取任务列表

### 请求

```
GET /api/v1/questions/extract/tasks?limit=20
Authorization: Bearer <token>
```

| 参数 | 类型 | 必填 | 说明 |
|------|------|------|------|
| `limit` | int | 否 | 返回数量，默认 20，最大 100 |

### 响应

```json
{
  "code": 200,
  "message": "获取成功",
  "data": [
    {
      "task_id": "550e8400-...",
      "filename": "Python面试题.pdf",
      "bank_id": "bank-001",
      "status": "completed",
      "total_chunks": 3,
      "processed_chunks": 3,
      "progress": 100.0,
      "total_questions": 12,
      "error": null,
      "created_at": 1739577600.0,
      "updated_at": 1739577620.0
    }
  ]
}
```

---

## 5. 批量导入题目到题库

用户在前端预览提取结果后，选择要导入的题目正式写入数据库。

### 请求

```
POST /api/v1/questions/extract/import
Content-Type: application/json
Authorization: Bearer <token>
```

```json
{
  "task_id": "550e8400-...",
  "bank_id": "bank-001",
  "question_indices": [0, 2, 5]
}
```

| 字段 | 类型 | 必填 | 说明 |
|------|------|------|------|
| `task_id` | string | 是 | 提取任务 ID |
| `bank_id` | string | 是 | 目标题库 ID |
| `question_indices` | int[] | 否 | 要导入的题目索引（从 0 开始），为空则导入全部 |

### 响应

```json
{
  "code": 200,
  "message": "成功导入 3 道题目",
  "data": [
    {
      "id": "q-001",
      "bank_id": "bank-001",
      "title": "Python中GIL是什么？",
      "content": "...",
      "type": "technical",
      "category": "Python",
      "difficulty": "medium",
      "difficulty_score": 6,
      "tags": ["Python", "并发"],
      "usage_count": 0,
      "status": "active",
      "created_at": "2025-02-15T09:30:00"
    }
  ]
}
```

---

## 6. 题目数据字段说明

每道提取出的题目包含以下字段：

| 字段 | 类型 | 说明 |
|------|------|------|
| `title` | string | 题目标题（≤200字） |
| `content` | string | 题目完整内容 |
| `type` | string | 类型：`technical` / `scenario` / `algorithm` / `behavioral` |
| `category` | string | 分类，如 Python / Java / 数据库 / 系统设计 |
| `difficulty` | string | 难度：`easy` / `medium` / `hard` |
| `difficulty_score` | int | 难度分 1-10 |
| `tags` | string[] | 标签列表 |
| `reference_answer` | string | 参考答案（如文档中有） |
| `answer_key_points` | string[] | 答案要点列表 |

---

## 7. 完整前端交互流程

```
┌──────────────────────────────────────────────────────────┐
│  1. 用户选择文件 + 目标题库                                  │
│     ↓                                                      │
│  2. POST /extract (multipart/form-data)                    │
│     ↓                                                      │
│  3. 接收 SSE 事件流                                         │
│     ├─ task_created  → 保存 task_id, 显示进度条              │
│     ├─ chunk_progress → 更新进度, 追加题目到预览列表          │
│     ├─ completed     → 显示全部结果, 清除 task_id            │
│     └─ error         → 显示错误, 展示已提取的部分结果         │
│     ↓                                                      │
│  4. 用户预览题目，勾选要导入的                                │
│     ↓                                                      │
│  5. POST /extract/import → 正式入库                         │
│                                                            │
│  ※ 刷新恢复：                                               │
│     页面加载时检查 localStorage 中是否有 task_id              │
│     如有 → GET /extract/tasks/{task_id} 恢复结果             │
└──────────────────────────────────────────────────────────┘
```

---

## 8. 错误码说明

| HTTP 状态码 | 场景 | message |
|------------|------|---------|
| 400 | 目标题库不存在 | "目标题库不存在" |
| 400 | 该任务没有提取到题目 | "该任务没有提取到题目" |
| 400 | 没有可导入的题目 | "没有可导入的题目" |
| 401 | 未登录 | "无效的认证凭证" |
| 404 | 任务不存在 | "任务不存在" |
| 404 | 提取任务不存在 | "提取任务不存在" |
| 422 | 参数校验失败 | 具体字段错误信息 |

---

## 9. 注意事项

- **文件大小**：最大 50MB
- **支持格式**：`.txt` `.md` `.docx` `.pdf`（扫描件/图片 PDF 不支持）
- **大文件处理**：后端自动将文本分块处理（每块约 6000 字符），避免超过 LLM 上下文窗口
- **结果缓存**：提取结果以 JSON 文件形式保存在服务端 `data/extraction_tasks/` 目录，前端刷新不丢失
- **SSE 连接**：如果网络中断，通过 `GET /extract/tasks/{task_id}` 获取已有结果即可
- **导入是独立步骤**：提取只是预览，需要用户确认后调用 `/extract/import` 才会正式写入数据库
